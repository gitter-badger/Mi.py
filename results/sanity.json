{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'aiohttp'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/abc/ext/bot.py",
      "language": "Python",
      "line": 6,
      "offset": 5,
      "length": 7,
      "code": {
        "startLine": 4,
        "length": 7,
        "offset": 73,
        "surroundingCode": "from typing import Any, Callable, Coroutine, Dict, Optional, Tuple\n\nfrom aiohttp.client_ws import ClientWebSocketResponse\n\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "-523767536775350413"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'ClientWebSocketResponse'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/abc/ext/bot.py",
      "language": "Python",
      "line": 6,
      "offset": 30,
      "length": 23,
      "code": {
        "startLine": 4,
        "length": 23,
        "offset": 98,
        "surroundingCode": "from typing import Any, Callable, Coroutine, Dict, Optional, Tuple\n\nfrom aiohttp.client_ws import ClientWebSocketResponse\n\n\nclass AbstractBotBase:\n    @abstractmethod\n    async def _on_message(self, message):"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "-8925984524421530831"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'aiohttp'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/bot.py",
      "language": "Python",
      "line": 27,
      "offset": 9,
      "length": 7,
      "code": {
        "startLine": 25,
        "length": 7,
        "offset": 28,
        "surroundingCode": "\nif TYPE_CHECKING:\n    from aiohttp.client_ws import ClientWebSocketResponse\n    from mi.ext import Cog\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "-1706632047199865921"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Module 'ClientWebSocketResponse' not found",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/bot.py",
      "language": "Python",
      "line": 27,
      "offset": 34,
      "length": 23,
      "code": {
        "startLine": 25,
        "length": 23,
        "offset": 53,
        "surroundingCode": "\nif TYPE_CHECKING:\n    from aiohttp.client_ws import ClientWebSocketResponse\n    from mi.ext import Cog\n\n__all__ = [\"BotBase\", \"Bot\"]"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "7775218344591340219"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved attribute reference '_eject' for class 'Cog'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/bot.py",
      "language": "Python",
      "line": 154,
      "offset": 12,
      "length": 6,
      "code": {
        "startLine": 152,
        "length": 6,
        "offset": 32,
        "surroundingCode": "            return\n\n        cog._eject(self)\n\n        return cog"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "5691193706955178652"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved attribute reference 'setup' for class 'ModuleType'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/bot.py",
      "language": "Python",
      "line": 160,
      "offset": 25,
      "length": 5,
      "code": {
        "startLine": 158,
        "length": 5,
        "offset": 107,
        "surroundingCode": "    def _load_from_module(self, spec: ModuleType, key: str) -> None:\n        try:\n            setup = spec.setup\n        except AttributeError:\n            raise NoEntryPointError(f\"{key} にsetupが存在しません\")\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "-4494790026829030837"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Class '(Any)' does not define '__setitem__', so the '[]' operator cannot be used on its instances",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/cog.py",
      "language": "Python",
      "line": 16,
      "offset": 13,
      "length": 1,
      "code": {
        "startLine": 14,
        "length": 1,
        "offset": 114,
        "surroundingCode": "    def __new__(cls, *args: Tuple[Any], **kwargs: Dict[str, Any]):\n        name, bases, attrs = args\n        attrs['__cog_name__'] = kwargs.pop(\"name\", name)\n        attrs['__cog_settings__'] = kwargs.pop(\"command_attrs\", {})\n        listeners = {}"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "4785023931847927593"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Class '(Any)' does not define '__setitem__', so the '[]' operator cannot be used on its instances",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/cog.py",
      "language": "Python",
      "line": 17,
      "offset": 13,
      "length": 1,
      "code": {
        "startLine": 15,
        "length": 1,
        "offset": 104,
        "surroundingCode": "        name, bases, attrs = args\n        attrs['__cog_name__'] = kwargs.pop(\"name\", name)\n        attrs['__cog_settings__'] = kwargs.pop(\"command_attrs\", {})\n        listeners = {}\n        commands = {}"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "-2619394791126357834"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Cannot find reference '__cog_listener_names__' in '(...) -> Any | (...) -> Coroutine'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/cog.py",
      "language": "Python",
      "line": 83,
      "offset": 23,
      "length": 22,
      "code": {
        "startLine": 81,
        "length": 22,
        "offset": 88,
        "surroundingCode": "            to_assign = name or actual.__name__\n            try:\n                actual.__cog_listener_names__.append(to_assign)\n            except AttributeError:\n                actual.__cog_listener_names__ = [to_assign]"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "-2629571643125026633"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'ExpectedClosingQuoteError'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/view.py",
      "language": "Python",
      "line": 145,
      "offset": 26,
      "length": 25,
      "code": {
        "startLine": 143,
        "length": 25,
        "offset": 93,
        "surroundingCode": "                if is_quoted:\n                    # unexpected EOF\n                    raise ExpectedClosingQuoteError(close_quote)\n                return \"\".join(result)\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "4093434177615791252"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'ExpectedClosingQuoteError'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/view.py",
      "language": "Python",
      "line": 156,
      "offset": 30,
      "length": 25,
      "code": {
        "startLine": 154,
        "length": 25,
        "offset": 143,
        "surroundingCode": "                    if is_quoted:\n                        # if we're quoted then we're expecting a closing quote\n                        raise ExpectedClosingQuoteError(close_quote)\n                    # if we aren't then we just let it through\n                    return \"\".join(result)"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "9188920636823446698"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'UnexpectedQuoteError'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/view.py",
      "language": "Python",
      "line": 171,
      "offset": 22,
      "length": 20,
      "code": {
        "startLine": 169,
        "length": 20,
        "offset": 114,
        "surroundingCode": "            if not is_quoted and current in _all_quotes:\n                # we aren't quoted\n                raise UnexpectedQuoteError(current)\n\n            # closing quote"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "8680210887934405435"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'InvalidEndOfQuotedStringError'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/ext/commands/view.py",
      "language": "Python",
      "line": 178,
      "offset": 26,
      "length": 29,
      "code": {
        "startLine": 176,
        "length": 29,
        "offset": 125,
        "surroundingCode": "                valid_eof = not next_char or next_char.isspace()\n                if not valid_eof:\n                    raise InvalidEndOfQuotedStringError(next_char)\n\n                # we're quoted so it's okay"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "2315342531971629336"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unused import statement <code>from dataclasses import dataclass</code>",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/models/user.py",
      "language": "Python",
      "line": 1,
      "offset": 0,
      "length": 33,
      "code": {
        "startLine": 1,
        "length": 33,
        "offset": 0,
        "surroundingCode": "from dataclasses import dataclass\nfrom typing import List, Optional\n\nfrom mi.models.instance import RawInstance"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "-6760465316459842"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "No module named 'aiohttp'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/http.py",
      "language": "Python",
      "line": 7,
      "offset": 7,
      "length": 7,
      "code": {
        "startLine": 5,
        "length": 7,
        "offset": 47,
        "surroundingCode": "from typing import Any, Dict, Optional\n\nimport aiohttp\n\nfrom mi.gateway import MisskeyClientWebSocketResponse\nfrom mi.utils import remove_dict_empty, upper_to_lower\nfrom . import __version__, config, exception"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "7402005466768699327"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved attribute reference 'follow_user' for class 'ConnectionState'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/note.py",
      "language": "Python",
      "line": 42,
      "offset": 33,
      "length": 11,
      "code": {
        "startLine": 40,
        "length": 11,
        "offset": 109,
        "surroundingCode": "        if self.id:\n            raise NotExistRequiredData('user_idがありません')\n        return await self._state.follow_user(user_id=self.id)\n\n    async def unfollow(self, user_id: Optional[str] = None) -> bool:"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "8694995475221388627"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved attribute reference 'unfollow_user' for class 'ConnectionState'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/note.py",
      "language": "Python",
      "line": 61,
      "offset": 33,
      "length": 13,
      "code": {
        "startLine": 59,
        "length": 13,
        "offset": 96,
        "surroundingCode": "        if user_id is None:\n            user_id = self.user.id\n        return await self._state.unfollow_user(user_id)\n\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "-871076916140566621"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'id'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/note.py",
      "language": "Python",
      "line": 273,
      "offset": 4,
      "length": 2,
      "code": {
        "startLine": 271,
        "length": 2,
        "offset": 35,
        "surroundingCode": "    Attributes\n    -----------\n    id: str \n    created_at: str\n    user_id: str"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "-1476116858418506511"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Python",
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'created_at'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n```\ndef print_string(s):\n  print(s.abc())\n```\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "mi/note.py",
      "language": "Python",
      "line": 274,
      "offset": 4,
      "length": 10,
      "code": {
        "startLine": 272,
        "length": 10,
        "offset": 33,
        "surroundingCode": "    -----------\n    id: str \n    created_at: str\n    user_id: str\n    author: User"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "2672223202437764741"
}]}